<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Air Quality — Map</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Simple styling -->
  <style>
    html,body { height:100%; margin:0; font-family:system-ui,Arial; }
    #map { position:absolute; top:0; right:0; bottom:0; left:300px; }
    #panel {
      position:absolute; left:10px; top:10px; width:280px;
      background: rgba(255,255,255,0.95); padding:12px; border-radius:8px;
      box-shadow:0 6px 18px rgba(0,0,0,0.12);
      max-height: calc(100% - 40px); overflow:auto;
    }
    button,input,select { width:100%; padding:8px; margin:6px 0; box-sizing:border-box; }
    h3 { margin:6px 0 10px; font-size:16px; }
    small { color:#666; display:block; margin-top:6px; }
    #log { font-size:13px; color:#111; background:#f8f8f8; padding:8px; border-radius:6px; max-height:150px; overflow:auto; }
    .route-fast { color: #1f77b4; }
    .route-safe { color: #2ca02c; }
  </style>
</head>
<body>

<div id="panel">
  <h3>Air Quality Map</h3>

  <button id="btnLoadStations">Load stations</button>
  <button id="btnToggleHeat">Toggle heatmap</button>
  <button id="btnInterpolate">Run /interpolate (server-side)</button>

  <p><strong>Routes</strong></p>
  <small>Click map for <em>Start</em> then <em>End</em>.</small>
  <button id="btnClearRoutes">Clear routes</button>

  <hr/>

  <p><strong>Predict (single)</strong></p>
  <label>lat</label><input id="inpLat" type="number" step="0.000001" value="28.6139"/>
  <label>lon</label><input id="inpLon" type="number" step="0.000001" value="77.2090"/>
  <label>timestamp (UTC)</label><input id="inpTs" type="datetime-local" />
  <label>pm2.5</label><input id="inpPm25" type="number" value="80"/>
  <label>pm10</label><input id="inpPm10" type="number" value="120"/>
  <label>temperature_2m</label><input id="inpTemp" type="number" value="28.5"/>
  <label>relativehumidity_2m</label><input id="inpHum" type="number" value="45"/>
  <label>windspeed_10m</label><input id="inpWind" type="number" value="3.2"/>
  <label>winddirection_10m</label><input id="inpWindDir" type="number" value="210"/>
  <label>station_code</label><input id="inpStation" type="number" value="101"/>
  <button id="btnPredict">Predict 1-hour AQI</button>

  <div id="prediction" style="padding:8px;margin-top:6px;border-radius:6px;background:#fff;border:1px solid #eee;">
    <strong>Pred:</strong> <span id="predVal">N/A</span> — <span id="predCat">N/A</span><br/>
    <small>Predicted for: <span id="predTs">N/A</span></small>
  </div>

  <hr/>
  <p><strong>Status / logs</strong></p>
  <div id="log">idle</div>
</div>

<div id="map"></div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- Leaflet.heat for heatmaps -->
<script src="https://unpkg.com/leaflet.heat"></script>

<script>
(async function () {
  // Update these if your API is on a different host / port.
  const API_BASE = "http://127.0.0.1:8010";

  // Simple helper
  function log(...args) {
    const el = document.getElementById('log');
    const msg = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : a)).join(' ');
    el.innerText = msg + '\n' + el.innerText;
    console.log(...args);
  }
  async function fetchJson(url, opts = {}) {
    const r = await fetch(url, opts);
    const txt = await r.text();
    try { return JSON.parse(txt); } catch(e) {
      throw new Error(`Invalid JSON from ${url}: ${txt}`);
    }
  }

  // initialize map
  const map = L.map('map').setView([28.63, 77.22], 11);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19, attribution: '© OSM'
  }).addTo(map);

  // UI elements
  const btnLoadStations = document.getElementById('btnLoadStations');
  const btnToggleHeat = document.getElementById('btnToggleHeat');
  const btnInterpolate = document.getElementById('btnInterpolate');
  const btnClearRoutes = document.getElementById('btnClearRoutes');
  const btnPredict = document.getElementById('btnPredict');

  const inpLat = document.getElementById('inpLat');
  const inpLon = document.getElementById('inpLon');
  const inpTs = document.getElementById('inpTs');
  const inpPm25 = document.getElementById('inpPm25');
  const inpPm10 = document.getElementById('inpPm10');
  const inpTemp = document.getElementById('inpTemp');
  const inpHum = document.getElementById('inpHum');
  const inpWind = document.getElementById('inpWind');
  const inpWindDir = document.getElementById('inpWindDir');
  const inpStation = document.getElementById('inpStation');

  const predVal = document.getElementById('predVal');
  const predCat = document.getElementById('predCat');
  const predTs = document.getElementById('predTs');

  // station markers and heat layer
  let markers = L.layerGroup().addTo(map);
  let heatLayer = null;
  let gridCache = null;

  // routes
  let routeFast = null;
  let routeSafe = null;
  let clickState = 0;
  let startCoord = null;
  let endCoord = null;

  // format datetime-local input to ISO with Z (UTC)
  function localToIsoUTC(value) {
    if (!value) return new Date().toISOString();
    const dt = new Date(value);
    return new Date(dt.getTime() - dt.getTimezoneOffset() * 60000).toISOString(); // UTC iso
  }

  // load stations
  async function loadStations() {
    try {
      log('loading stations from', API_BASE + '/stations');
      const raw = await fetchJson(API_BASE + '/stations');
      // API should return an array; if object, try to pick .stations or .data
      let data = raw;
      if (raw && raw.stations) data = raw.stations;
      if (!Array.isArray(data)) {
        throw new Error('stations route returned non-array: ' + JSON.stringify(raw));
      }
      markers.clearLayers();
      data.forEach(s => {
        const lat = parseFloat(s.lat || s.latitude || s.y);
        const lon = parseFloat(s.lon || s.longitude || s.x);
        const label = s.station_code || s.stationId || s.code || s.id || '';
        if (isFinite(lat) && isFinite(lon)) {
          L.marker([lat, lon]).bindPopup(`<b>${label}</b><br/>${s.name||''}`).addTo(markers);
        }
      });
      map.fitBounds(markers.getBounds(), { padding:[20,20] });
      log(`stations loaded: ${data.length}`);
    } catch (err) {
      log('Failed to load stations:', err.message || err);
      alert('Failed to load stations: ' + (err.message || err));
    }
  }

  btnLoadStations.addEventListener('click', loadStations);

  // heat toggle: fetch grid (if needed) and draw heat
  async function toggleHeat() {
    try {
      if (!gridCache) {
        log('fetching grid from', API_BASE + '/grid');
        const g = await fetchJson(API_BASE + '/grid');
        // expect {lat, lon, pm25} array or {grid: [...]}
        let grid = g;
        if (g && g.grid) grid = g.grid;
        if (!Array.isArray(grid) && g && Array.isArray(g.grid_points)) grid = g.grid_points;
        if (!Array.isArray(grid) && Array.isArray(g)) grid = g;
        if (!Array.isArray(grid)) {
          // maybe server returned {path:...} — try reading saved file this session
          log('Grid endpoint returned unexpected shape:', g);
          alert('Grid data not available. Try "Run /interpolate" first.');
          return;
        }
        // convert to heat array: [lat, lon, intensity]
        const heatPoints = grid.map(p => [parseFloat(p.lat), parseFloat(p.lon), parseFloat(p.pm25 || p.value || 1)]);
        gridCache = heatPoints;
      }
      if (!heatLayer) {
        heatLayer = L.heatLayer(gridCache, { radius: 25, blur: 15, maxZoom: 17 }).addTo(map);
        log('Heatmap added, points:', gridCache.length);
      } else {
        map.removeLayer(heatLayer);
        heatLayer = null;
        log('Heatmap removed');
      }
    } catch (err) {
      log('Failed to toggle heatmap:', err.message || err);
      alert('Failed to toggle heatmap: ' + (err.message || err));
    }
  }
  btnToggleHeat.addEventListener('click', toggleHeat);

  // server-side interpolation
  btnInterpolate.addEventListener('click', async () => {
    try {
      log('triggering server interpolate...');
      const url = `${API_BASE}/interpolate?force=true`;
      const res = await fetchJson(url);
      log('interpolate result:', res);
      alert('interpolate result: ' + JSON.stringify(res));
      // clear cache and add heat
      gridCache = null;
      if (heatLayer) { map.removeLayer(heatLayer); heatLayer = null; }
      await toggleHeat();
    } catch (err) {
      log('Interpolate failed:', err.message || err);
      alert('Interpolate failed: ' + (err.message || err));
    }
  });

  // Click-to-select start & end for routes
  map.on('click', e => {
    if (clickState === 0) {
      startCoord = [e.latlng.lat, e.latlng.lng];
      clickState = 1;
      L.marker(startCoord).bindPopup('Start').addTo(map).openPopup();
      log('Start set', startCoord);
    } else {
      endCoord = [e.latlng.lat, e.latlng.lng];
      clickState = 0;
      L.marker(endCoord).bindPopup('End').addTo(map).openPopup();
      log('End set', endCoord);
      computeRoutes();
    }
  });

  btnClearRoutes.addEventListener('click', () => {
    if (routeFast) map.removeLayer(routeFast);
    if (routeSafe) map.removeLayer(routeSafe);
    routeFast = routeSafe = null;
    startCoord = endCoord = null;
    clickState = 0;
    log('routes cleared');
  });

  // compute routes via /safe_route (server returns coords arrays)
  async function computeRoutes() {
    if (!startCoord || !endCoord) return;
    try {
      log('requesting safe_route...');
      const url = new URL(API_BASE + '/safe_route');
      url.searchParams.set('start_lat', startCoord[0]);
      url.searchParams.set('start_lon', startCoord[1]);
      url.searchParams.set('end_lat', endCoord[0]);
      url.searchParams.set('end_lon', endCoord[1]);
      url.searchParams.set('samples', 80);
      const res = await fetchJson(url.toString());
      log('safe_route response', res);
      if (res.fast_route && res.fast_route.coords) {
        if (routeFast) map.removeLayer(routeFast);
        routeFast = L.polyline(res.fast_route.coords.map(c => [c[0], c[1]]), { color:'#1f77b4', weight:4 }).addTo(map);
      }
      if (res.safe_route && res.safe_route.coords) {
        if (routeSafe) map.removeLayer(routeSafe);
        routeSafe = L.polyline(res.safe_route.coords.map(c => [c[0], c[1]]), { color:'#2ca02c', weight:3 }).addTo(map);
      }
      map.fitBounds(L.featureGroup([routeFast, routeSafe]).getBounds(), { padding:[20,20] });
      log('routes drawn. exposures:', res.fast_route?.exposure, res.safe_route?.exposure);
    } catch (err) {
      log('Failed to compute routes:', err.message || err);
      alert('Failed to compute routes: ' + (err.message || err));
    }
  }

  // Predict event
  btnPredict.addEventListener('click', async () => {
    try {
      const payload = {
        lat: parseFloat(inpLat.value),
        lon: parseFloat(inpLon.value),
        ts: localToIsoUTC(inpTs.value),
        pm25: parseFloat(inpPm25.value),
        pm10: parseFloat(inpPm10.value),
        temperature_2m: parseFloat(inpTemp.value),
        relativehumidity_2m: parseFloat(inpHum.value),
        windspeed_10m: parseFloat(inpWind.value),
        winddirection_10m: parseFloat(inpWindDir.value),
        fire_count: 0.0,
        mean_frp: 0.0,
        station_code: parseInt(inpStation.value || 0, 10)
      };
      log('predict payload', payload);

      const res = await fetchJson(API_BASE + '/predict', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (res.predicted_aqi !== undefined) {
        predVal.innerText = res.predicted_aqi;
        predCat.innerText = res.category || 'N/A';
        predTs.innerText = res.timestamp_predicted_for || 'N/A';
        log('predict success', res);
      } else {
        log('predict response unexpected', res);
        alert('Predict returned unexpected response. See console.');
      }
    } catch (err) {
      log('Predict failed:', err.message || err);
      alert('Predict failed: ' + (err.message || err));
    }
  });

  // small convenience: load stations on startup
  try { loadStations(); } catch(e) { log('initial loadStations failed', e); }

  // helpful: keyboard shortcut "i" to trigger interpolate
  window.addEventListener('keydown', e => { if (e.key === 'i') btnInterpolate.click(); });

})();
</script>
</body>
</html>
